# -*- coding: utf-8 -*-
"""
OfficeAI - Chatbot Inteligente con BÃºsqueda Web
VersiÃ³n Refactorizada 2.0
"""
import webbrowser

from config import PERSONALITY, DATA_DIR, DB_PATH
from database import Database
from search import WebSearch
from ai_engine import AIEngine
from utils import setup_logging, print_banner, print_stats


def handle_correction(ai):
    """Maneja una correcciÃ³n del usuario"""
    if not ai.last_question:
        print(f"\n{PERSONALITY['name']}: No hay pregunta previa para corregir.")
        return
    
    print(f"\n{PERSONALITY['name']}: Lo siento, la respuesta anterior no era correcta.")
    new_answer = input("Escribe la respuesta correcta:\n").strip()
    
    if new_answer:
        ai.handle_user_correction(new_answer)
        print(f"{PERSONALITY['name']}: Gracias, he aprendido y lo recordarÃ©.")


def handle_single_answer(ai, question, answer):
    """Maneja una respuesta Ãºnica"""
    print(f"\n{PERSONALITY['name']}: {answer}")
    
    # AÃ±adir al contexto conversacional
    ai.add_to_context(question, answer)
    
    confirm = input("\nÂ¿Es esta respuesta correcta? (si/no): ").strip().lower()
    
    if confirm in ["si", "sÃ­", "s", "yes", "y"]:
        ai.db.update_q_value(question, answer, +2.0)
        print(f"{PERSONALITY['name']}: Â¡Perfecto! AumentarÃ© la confianza en esta respuesta.")
    else:
        new_answer = input("Escribe la respuesta correcta:\n").strip()
        if new_answer:
            ai.handle_user_correction(new_answer, question)
            return False
    
    suggest = input("\nÂ¿Quieres aÃ±adir otra respuesta alternativa para esta pregunta? (si/no): ").strip().lower()
    return suggest in ["si", "sÃ­", "s", "yes", "y"]


def handle_multiple_answers(ai, question, answers):
    """Maneja mÃºltiples respuestas posibles"""
    print(f"\n{PERSONALITY['name']}: Tengo {len(answers)} respuestas posibles, elige la mejor:")
    
    for idx, ans_dict in enumerate(answers, 1):
        ans = ans_dict['answer']
        q_value = ans_dict.get('q_value', 0)
        times = ans_dict.get('times_selected', 0)
        print(f"{idx}. {ans}")
        if times > 0:
            print(f"   (confianza: {q_value:.1f}, usada {times} veces)")
    
    choice = input(f"\nElige (1-{len(answers)}) o '0' si ninguna es correcta: ").strip()
    
    if choice.isdigit() and 1 <= int(choice) <= len(answers):
        selected = answers[int(choice)-1]['answer']
        ai.handle_answer_selection(question, selected, is_correct=True)
        print(f"\n{PERSONALITY['name']}: Perfecto, usarÃ© esta respuesta mÃ¡s a menudo.")
        return True
    else:
        new_answer = input("Escribe la respuesta correcta:\n").strip()
        if new_answer:
            ai.handle_user_correction(new_answer, question)
            return True
    
    return False


def handle_web_search(ai, question):
    """Maneja bÃºsqueda web cuando no hay respuesta local"""
    print(f"\n{PERSONALITY['name']}: No tengo esa informaciÃ³n guardada localmente.")
    print("Buscando en internet ahora mismo...")
    
    results = ai.search_web_and_process(question)
    
    if results:
        print(f"\n{PERSONALITY['name']}: AquÃ­ tienes informaciÃ³n actualizada de la web:\n")
        
        for i, r in enumerate(results, 1):
            print(f"{i}. {r['title']}")
            print(f"   {r['body']}")
            print(f"   ðŸ”— {r['href']}\n")
        
        open_link = input("Â¿Quieres abrir uno de los enlaces? (1/2/3/4 o no): ").strip()
        if open_link.isdigit() and 1 <= int(open_link) <= len(results):
            url = results[int(open_link)-1]['href']
            webbrowser.open(url)
            print("Abriendo en tu navegador...")
        
        teach = input("\nÂ¿Quieres enseÃ±arme la respuesta correcta para guardarla? (si/no): ").strip().lower()
        if teach in ["si", "sÃ­", "s", "yes", "y"]:
            resp = input("Escribe la respuesta que consideras correcta:\n").strip()
            if resp:
                topic = ai.get_topic(question)
                ai.db.add_knowledge(question, resp, topic)
                ai.db.update_q_value(question, resp, +2.0)
                ai.db.add_to_history(question, resp, 'user_teach')
                print(f"{PERSONALITY['name']}: Â¡Perfecto! La prÃ³xima vez te darÃ© esta respuesta directamente.")
    else:
        print(f"{PERSONALITY['name']}: Lo siento, la bÃºsqueda no devolviÃ³ resultados Ãºtiles.")


def show_history(db):
    """Muestra el historial de conversaciones"""
    history = db.get_history(limit=20)
    
    if not history:
        print("\nNo hay historial aÃºn.")
        return
    
    print("\n" + "="*80)
    print("HISTORIAL DE CONVERSACIONES (Ãºltimas 20)")
    print("="*80)
    
    for entry in reversed(history):
        timestamp = entry['timestamp']
        question = entry['question']
        answer = entry['answer']
        source = entry['source']
        was_correct = entry.get('was_correct')
        
        print(f"\n[{timestamp}]")
        print(f"TÃº: {question}")
        print(f"{PERSONALITY['name']}: {answer}")
        print(f"Fuente: {source}", end="")
        
        if was_correct is not None:
            status = "âœ“ Correcta" if was_correct else "âœ— Incorrecta"
            print(f" | {status}")
        else:
            print()
    
    print("\n" + "="*80)


def main():
    """FunciÃ³n principal del chatbot"""
    logger = setup_logging()
    logger.info("Iniciando OfficeAI v2.0")
    
    print_banner(PERSONALITY)
    
    try:
        db = Database()
        web_search = WebSearch(db)
        ai = AIEngine(db, web_search)
        
        logger.info("Componentes inicializados correctamente")
        print(f"Base de datos: {DB_PATH}")
        print(f"Conocimiento cargado: {db.get_knowledge_count()} entradas")
        print("\nComandos especiales:")
        print("  'salir' - Terminar programa")
        print("  'historial' - Ver conversaciones anteriores")
        print("  'stats' - Ver estadÃ­sticas del sistema")
        print("  'export' - Exportar base de datos a JSON")
        print("="*80)
        
    except Exception as e:
        print(f"ERROR CRÃTICO: No se pudo inicializar el sistema: {e}")
        logger.error(f"Error de inicializaciÃ³n: {e}")
        return
    
    while True:
        try:
            q = input("\nTÃº: ").strip()
            
            if not q:
                continue
            
            if q.lower() == "salir":
                print(f"\n{PERSONALITY['name']}: Â¡Hasta luego! Que tengas un excelente dÃ­a.")
                logger.info("Usuario cerrÃ³ sesiÃ³n")
                break
            
            if q.lower() == "historial":
                show_history(db)
                continue
            
            if q.lower() == "stats":
                print_stats(ai.get_stats())
                continue
            
            if q.lower() == "export":
                export_path = DATA_DIR / "backup.json"
                if db.export_to_json(str(export_path)):
                    print(f"âœ“ Base de datos exportada a: {export_path}")
                else:
                    print("âœ— Error al exportar base de datos")
                continue
            
            if ai.is_correction(q) and ai.last_question:
                handle_correction(ai)
                continue
            
            answer, source = ai.process_question(q)
            
            if source == 'local':
                if handle_single_answer(ai, q, answer):
                    alt_answer = input("Escribe la respuesta alternativa:\n").strip()
                    if alt_answer:
                        ai.add_alternative_answer(q, alt_answer)
                        print(f"{PERSONALITY['name']}: Alternativa aÃ±adida correctamente.")
            
            elif source == 'local_multi':
                handle_multiple_answers(ai, q, answer)
            
            elif source == 'unknown':
                handle_web_search(ai, q)
            
        except KeyboardInterrupt:
            print(f"\n\n{PERSONALITY['name']}: SesiÃ³n interrumpida. Â¡Hasta pronto!")
            logger.info("SesiÃ³n interrumpida por usuario (Ctrl+C)")
            break
        
        except Exception as e:
            print(f"\n{PERSONALITY['name']}: Lo siento, ocurriÃ³ un error inesperado.")
            logger.error(f"Error en loop principal: {e}", exc_info=True)
            continue


if __name__ == "__main__":
    main()